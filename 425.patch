From a2adfa045752c6f961e15b5fa4c9304e88bb39a8 Mon Sep 17 00:00:00 2001
From: cs8425 <cs8425@gmail.com>
Date: Tue, 7 Feb 2017 23:27:47 +0800
Subject: [PATCH 1/3] add support for connect over raw tcp socket

---
 js/serial.js  | 101 ++++++++++++++++++++++++++++++++++++++++++++------
 manifest.json |   7 +++-
 2 files changed, 95 insertions(+), 13 deletions(-)

diff --git a/js/serial.js b/js/serial.js
index d91d5fd271..e8c760073d 100644
--- a/js/serial.js
+++ b/js/serial.js
@@ -1,6 +1,9 @@
 'use strict';
 
 var serial = {
+    connectionType:  'serial', // 'serial' or 'tcp'
+    connectionIP:    '127.0.0.1',
+    connectionPort:  2323,
     connectionId:    false,
     openRequested:   false,
     openCanceled:    false,
@@ -12,10 +15,76 @@ var serial = {
     transmitting:   false,
     outputBuffer:  [],
 
+    LOGHEAD: 'SERIAL: ',
+
     connect: function (path, options, callback) {
         var self = this;
         self.openRequested = true;
 
+        var testUrl = path.match(/tcp:\/\/(.*):(.*)/)
+        if (testUrl) {
+            self.connectionIP = testUrl[1];
+            self.connectionPort = testUrl[2] || self.connectionPort;
+            self.connectionPort = parseInt(self.connectionPort);
+            self.connectionType = 'tcp';
+            self.LOGHEAD = 'SERIAL-TCP: ';
+            console.log('connect to raw tcp:', self.connectionIP + ':' + self.connectionPort)
+
+        chrome.sockets.tcp.create({}, function(createInfo) {
+            console.log('chrome.sockets.tcp.create', createInfo)
+            if (createInfo && !self.openCanceled) {
+                self.connectionId = createInfo.socketId;
+                self.bitrate = 115200; // fake
+                self.bytesReceived = 0;
+                self.bytesSent = 0;
+                self.failed = 0;
+                self.openRequested = false;
+            }
+
+
+            chrome.sockets.tcp.connect(createInfo.socketId, self.connectionIP, self.connectionPort, function (result){
+                if (chrome.runtime.lastError) {
+                    console.error('onConnectedCallback', chrome.runtime.lastError.message);
+                }
+
+                console.log('onConnectedCallback', result)
+                if(result == 0) {
+                    chrome.sockets.tcp.setNoDelay(createInfo.socketId, true, function (noDelayResult){
+                        if (chrome.runtime.lastError) {
+                            console.error('setNoDelay', chrome.runtime.lastError.message);
+                        }
+
+                        console.log('setNoDelay', noDelayResult)
+                        if(noDelayResult != 0) {
+                            self.openRequested = false;
+                            console.log(self.LOGHEAD + 'Failed to setNoDelay');
+                        }
+                        self.onReceive.addListener(function log_bytesReceived(info) {
+                            if (info.socketId != self.connectionId) return;
+                            self.bytesReceived += info.data.byteLength;
+                        });
+                        self.onReceiveError.addListener(function watch_for_on_receive_errors(info) {
+                            console.error(info);
+                            if (info.socketId != self.connectionId) return;
+                        });
+
+                        console.log(self.LOGHEAD + 'Connection opened with ID: ' + createInfo.socketId + ', url: ' + self.connectionIP + ':' + self.connectionPort);
+
+                        if (callback) callback(createInfo);
+                    });
+                } else {
+                    self.openRequested = false;
+                    console.log(self.LOGHEAD + 'Failed to connect');
+                    if (callback) callback(false);
+                }
+
+            });
+        });
+
+        } else {
+            self.connectionType = 'serial';
+            self.LOGHEAD = 'SERIAL: ';
+
         chrome.serial.connect(path, options, function (connectionInfo) {
             if (chrome.runtime.lastError) {
                 console.error(chrome.runtime.lastError.message);
@@ -142,6 +211,7 @@ var serial = {
                 if (callback) callback(false);
             }
         });
+        }
     },
     disconnect: function (callback) {
         var self = this;
@@ -158,15 +228,16 @@ var serial = {
                 self.onReceiveError.removeListener(self.onReceiveError.listeners[i]);
             }
 
-            chrome.serial.disconnect(this.connectionId, function (result) {
+            var disconnectFn = (self.connectionType == 'serial') ? chrome.serial.disconnect : chrome.sockets.tcp.close;
+            disconnectFn(this.connectionId, function (result) {
                 if (chrome.runtime.lastError) {
                     console.error(chrome.runtime.lastError.message);
                 }
 
                 if (result) {
-                    console.log('SERIAL: Connection with ID: ' + self.connectionId + ' closed, Sent: ' + self.bytesSent + ' bytes, Received: ' + self.bytesReceived + ' bytes');
+                    console.log(self.LOGHEAD + 'Connection with ID: ' + self.connectionId + ' closed, Sent: ' + self.bytesSent + ' bytes, Received: ' + self.bytesReceived + ' bytes');
                 } else {
-                    console.log('SERIAL: Failed to close connection with ID: ' + self.connectionId + ' closed, Sent: ' + self.bytesSent + ' bytes, Received: ' + self.bytesReceived + ' bytes');
+                    console.log(self.LOGHEAD + 'Failed to close connection with ID: ' + self.connectionId + ' closed, Sent: ' + self.bytesSent + ' bytes, Received: ' + self.bytesReceived + ' bytes');
                 }
 
                 self.connectionId = false;
@@ -191,13 +262,14 @@ var serial = {
         });
     },
     getInfo: function (callback) {
-        chrome.serial.getInfo(this.connectionId, callback);
+        var chromeType = (self.connectionType == 'serial') ? chrome.serial : chrome.sockets.tcp;
+        chromeType.getInfo(this.connectionId, callback);
     },
     getControlSignals: function (callback) {
-        chrome.serial.getControlSignals(this.connectionId, callback);
+        if (self.connectionType == 'serial') chrome.serial.getControlSignals(this.connectionId, callback);
     },
     setControlSignals: function (signals, callback) {
-        chrome.serial.setControlSignals(this.connectionId, signals, callback);
+        if (self.connectionType == 'serial') chrome.serial.setControlSignals(this.connectionId, signals, callback);
     },
     send: function (data, callback) {
         var self = this;
@@ -208,7 +280,8 @@ var serial = {
             var data = self.outputBuffer[0].data,
                 callback = self.outputBuffer[0].callback;
 
-            chrome.serial.send(self.connectionId, data, function (sendInfo) {
+            var sendFn = (self.connectionType == 'serial') ? chrome.serial.send : chrome.sockets.tcp.send;
+            sendFn(self.connectionId, data, function (sendInfo) {
                 // track sent bytes for statistics
                 self.bytesSent += sendInfo.bytesSent;
 
@@ -229,7 +302,7 @@ var serial = {
                             counter++;
                         }
 
-                        console.log('SERIAL: Send buffer overflowing, dropped: ' + counter + ' entries');
+                        console.log(self.LOGHEAD + 'Send buffer overflowing, dropped: ' + counter + ' entries');
                     }
 
                     send();
@@ -248,13 +321,15 @@ var serial = {
         listeners: [],
 
         addListener: function (function_reference) {
-            chrome.serial.onReceive.addListener(function_reference);
+            var chromeType = (serial.connectionType == 'serial') ? chrome.serial : chrome.sockets.tcp;
+            chromeType.onReceive.addListener(function_reference);
             this.listeners.push(function_reference);
         },
         removeListener: function (function_reference) {
+            var chromeType = (serial.connectionType == 'serial') ? chrome.serial : chrome.sockets.tcp;
             for (var i = (this.listeners.length - 1); i >= 0; i--) {
                 if (this.listeners[i] == function_reference) {
-                    chrome.serial.onReceive.removeListener(function_reference);
+                    chromeType.onReceive.removeListener(function_reference);
 
                     this.listeners.splice(i, 1);
                     break;
@@ -266,13 +341,15 @@ var serial = {
         listeners: [],
 
         addListener: function (function_reference) {
-            chrome.serial.onReceiveError.addListener(function_reference);
+            var chromeType = (serial.connectionType == 'serial') ? chrome.serial : chrome.sockets.tcp;
+            chromeType.onReceiveError.addListener(function_reference);
             this.listeners.push(function_reference);
         },
         removeListener: function (function_reference) {
+            var chromeType = (serial.connectionType == 'serial') ? chrome.serial : chrome.sockets.tcp;
             for (var i = (this.listeners.length - 1); i >= 0; i--) {
                 if (this.listeners[i] == function_reference) {
-                    chrome.serial.onReceiveError.removeListener(function_reference);
+                    chromeType.onReceiveError.removeListener(function_reference);
 
                     this.listeners.splice(i, 1);
                     break;
diff --git a/manifest.json b/manifest.json
index 18d26b8d48..f645225a25 100644
--- a/manifest.json
+++ b/manifest.json
@@ -22,7 +22,7 @@
     "pages": ["tabs/map.html"]
     },
          
-        "permissions": [
+    "permissions": [
         "https://maps.googleapis.com/*",    
         "https://*.github.com/",
         "https://*.githubusercontent.com/",
@@ -40,6 +40,11 @@
             {"vendorId": 1155, "productId": 57105}
         ]}
     ],
+    "sockets": {
+        "tcp": {
+            "connect": "*:*"
+        }
+    },
 
     "icons": {
         "128": "images/bf_icon_128.png"

From 2f505314f5ebf6731965bf8355fc2c57a75fa9f4 Mon Sep 17 00:00:00 2001
From: cs8425 <cs8425@gmail.com>
Date: Wed, 8 Feb 2017 15:02:09 +0800
Subject: [PATCH 2/3] fixes / improvements some variable / branch

---
 js/serial.js | 156 +++++++++++++++++++++++++++------------------------
 1 file changed, 84 insertions(+), 72 deletions(-)

diff --git a/js/serial.js b/js/serial.js
index e8c760073d..46cad71a87 100644
--- a/js/serial.js
+++ b/js/serial.js
@@ -1,9 +1,6 @@
 'use strict';
 
 var serial = {
-    connectionType:  'serial', // 'serial' or 'tcp'
-    connectionIP:    '127.0.0.1',
-    connectionPort:  2323,
     connectionId:    false,
     openRequested:   false,
     openCanceled:    false,
@@ -11,79 +8,35 @@ var serial = {
     bytesReceived:   0,
     bytesSent:       0,
     failed:          0,
+    connectionType:  'serial', // 'serial' or 'tcp'
+    connectionIP:    '127.0.0.1',
+    connectionPort:  2323,
 
     transmitting:   false,
     outputBuffer:  [],
 
-    LOGHEAD: 'SERIAL: ',
+    logHead: 'SERIAL: ',
 
     connect: function (path, options, callback) {
         var self = this;
-        self.openRequested = true;
 
-        var testUrl = path.match(/tcp:\/\/(.*):(.*)/)
+        var testUrl = path.match(/^tcp:\/\/([A-Za-z0-9\.-]+)(?:\:(\d+))?$/)
         if (testUrl) {
-            self.connectionIP = testUrl[1];
-            self.connectionPort = testUrl[2] || self.connectionPort;
-            self.connectionPort = parseInt(self.connectionPort);
-            self.connectionType = 'tcp';
-            self.LOGHEAD = 'SERIAL-TCP: ';
-            console.log('connect to raw tcp:', self.connectionIP + ':' + self.connectionPort)
-
-        chrome.sockets.tcp.create({}, function(createInfo) {
-            console.log('chrome.sockets.tcp.create', createInfo)
-            if (createInfo && !self.openCanceled) {
-                self.connectionId = createInfo.socketId;
-                self.bitrate = 115200; // fake
-                self.bytesReceived = 0;
-                self.bytesSent = 0;
-                self.failed = 0;
-                self.openRequested = false;
-            }
-
-
-            chrome.sockets.tcp.connect(createInfo.socketId, self.connectionIP, self.connectionPort, function (result){
-                if (chrome.runtime.lastError) {
-                    console.error('onConnectedCallback', chrome.runtime.lastError.message);
-                }
-
-                console.log('onConnectedCallback', result)
-                if(result == 0) {
-                    chrome.sockets.tcp.setNoDelay(createInfo.socketId, true, function (noDelayResult){
-                        if (chrome.runtime.lastError) {
-                            console.error('setNoDelay', chrome.runtime.lastError.message);
-                        }
-
-                        console.log('setNoDelay', noDelayResult)
-                        if(noDelayResult != 0) {
-                            self.openRequested = false;
-                            console.log(self.LOGHEAD + 'Failed to setNoDelay');
-                        }
-                        self.onReceive.addListener(function log_bytesReceived(info) {
-                            if (info.socketId != self.connectionId) return;
-                            self.bytesReceived += info.data.byteLength;
-                        });
-                        self.onReceiveError.addListener(function watch_for_on_receive_errors(info) {
-                            console.error(info);
-                            if (info.socketId != self.connectionId) return;
-                        });
-
-                        console.log(self.LOGHEAD + 'Connection opened with ID: ' + createInfo.socketId + ', url: ' + self.connectionIP + ':' + self.connectionPort);
-
-                        if (callback) callback(createInfo);
-                    });
-                } else {
-                    self.openRequested = false;
-                    console.log(self.LOGHEAD + 'Failed to connect');
-                    if (callback) callback(false);
-                }
-
-            });
-        });
+            var ip = testUrl[1];
+            var port = testUrl[2] || self.connectionPort;
+            port = parseInt(self.connectionPort);
 
+            console.log('connect to raw tcp:', ip + ':' + port)
+            self.connectTcp(ip, port, options, callback);
         } else {
-            self.connectionType = 'serial';
-            self.LOGHEAD = 'SERIAL: ';
+            self.connectSerial(path, options, callback);
+        }
+    },
+    connectSerial: function (path, options, callback) {
+        var self = this;
+        self.openRequested = true;
+        self.connectionType = 'serial';
+        self.logHead = 'SERIAL: ';
 
         chrome.serial.connect(path, options, function (connectionInfo) {
             if (chrome.runtime.lastError) {
@@ -211,7 +164,65 @@ var serial = {
                 if (callback) callback(false);
             }
         });
-        }
+    },
+    connectTcp: function (ip, port, options, callback) {
+        var self = this;
+        self.openRequested = true;
+        self.connectionIP = ip;
+        self.connectionPort = port || 2323;
+        self.connectionPort = parseInt(self.connectionPort);
+        self.connectionType = 'tcp';
+        self.logHead = 'SERIAL-TCP: ';
+
+        chrome.sockets.tcp.create({}, function(createInfo) {
+            console.log('chrome.sockets.tcp.create', createInfo)
+            if (createInfo && !self.openCanceled) {
+                self.connectionId = createInfo.socketId;
+                self.bitrate = 115200; // fake
+                self.bytesReceived = 0;
+                self.bytesSent = 0;
+                self.failed = 0;
+                self.openRequested = false;
+            }
+
+            chrome.sockets.tcp.connect(createInfo.socketId, self.connectionIP, self.connectionPort, function (result){
+                if (chrome.runtime.lastError) {
+                    console.error('onConnectedCallback', chrome.runtime.lastError.message);
+                }
+
+                console.log('onConnectedCallback', result)
+                if(result == 0) {
+                    chrome.sockets.tcp.setNoDelay(createInfo.socketId, true, function (noDelayResult){
+                        if (chrome.runtime.lastError) {
+                            console.error('setNoDelay', chrome.runtime.lastError.message);
+                        }
+
+                        console.log('setNoDelay', noDelayResult)
+                        if(noDelayResult != 0) {
+                            self.openRequested = false;
+                            console.log(self.logHead + 'Failed to setNoDelay');
+                        }
+                        self.onReceive.addListener(function log_bytesReceived(info) {
+                            if (info.socketId != self.connectionId) return;
+                            self.bytesReceived += info.data.byteLength;
+                        });
+                        self.onReceiveError.addListener(function watch_for_on_receive_errors(info) {
+                            console.error(info);
+                            if (info.socketId != self.connectionId) return;
+                        });
+
+                        console.log(self.logHead + 'Connection opened with ID: ' + createInfo.socketId + ', url: ' + self.connectionIP + ':' + self.connectionPort);
+
+                        if (callback) callback(createInfo);
+                    });
+                } else {
+                    self.openRequested = false;
+                    console.log(self.logHead + 'Failed to connect');
+                    if (callback) callback(false);
+                }
+
+            });
+        });
     },
     disconnect: function (callback) {
         var self = this;
@@ -234,10 +245,11 @@ var serial = {
                     console.error(chrome.runtime.lastError.message);
                 }
 
+                result = result || self.connectionType == 'tcp'
                 if (result) {
-                    console.log(self.LOGHEAD + 'Connection with ID: ' + self.connectionId + ' closed, Sent: ' + self.bytesSent + ' bytes, Received: ' + self.bytesReceived + ' bytes');
+                    console.log(self.logHead + 'Connection with ID: ' + self.connectionId + ' closed, Sent: ' + self.bytesSent + ' bytes, Received: ' + self.bytesReceived + ' bytes');
                 } else {
-                    console.log(self.LOGHEAD + 'Failed to close connection with ID: ' + self.connectionId + ' closed, Sent: ' + self.bytesSent + ' bytes, Received: ' + self.bytesReceived + ' bytes');
+                    console.log(self.logHead + 'Failed to close connection with ID: ' + self.connectionId + ' closed, Sent: ' + self.bytesSent + ' bytes, Received: ' + self.bytesReceived + ' bytes');
                 }
 
                 self.connectionId = false;
@@ -262,14 +274,14 @@ var serial = {
         });
     },
     getInfo: function (callback) {
-        var chromeType = (self.connectionType == 'serial') ? chrome.serial : chrome.sockets.tcp;
+        var chromeType = (this.connectionType == 'serial') ? chrome.serial : chrome.sockets.tcp;
         chromeType.getInfo(this.connectionId, callback);
     },
     getControlSignals: function (callback) {
-        if (self.connectionType == 'serial') chrome.serial.getControlSignals(this.connectionId, callback);
+        if (this.connectionType == 'serial') chrome.serial.getControlSignals(this.connectionId, callback);
     },
     setControlSignals: function (signals, callback) {
-        if (self.connectionType == 'serial') chrome.serial.setControlSignals(this.connectionId, signals, callback);
+        if (this.connectionType == 'serial') chrome.serial.setControlSignals(this.connectionId, signals, callback);
     },
     send: function (data, callback) {
         var self = this;
@@ -302,7 +314,7 @@ var serial = {
                             counter++;
                         }
 
-                        console.log(self.LOGHEAD + 'Send buffer overflowing, dropped: ' + counter + ' entries');
+                        console.log(self.logHead + 'Send buffer overflowing, dropped: ' + counter + ' entries');
                     }
 
                     send();

From e3cb79989859abad67339a9b1435a8b81d9e8813 Mon Sep 17 00:00:00 2001
From: cs8425 <cs8425@gmail.com>
Date: Wed, 8 Feb 2017 16:36:44 +0800
Subject: [PATCH 3/3] a little better error handle

---
 js/serial.js | 34 ++++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/js/serial.js b/js/serial.js
index 46cad71a87..2e1414a49b 100644
--- a/js/serial.js
+++ b/js/serial.js
@@ -209,6 +209,20 @@ var serial = {
                         self.onReceiveError.addListener(function watch_for_on_receive_errors(info) {
                             console.error(info);
                             if (info.socketId != self.connectionId) return;
+
+                            // TODO: better error handle
+                            // error code: https://cs.chromium.org/chromium/src/net/base/net_error_list.h?sq=package:chromium&l=124
+                            switch (info.resultCode) {
+                                case -100: // CONNECTION_CLOSED
+                                case -102: // CONNECTION_REFUSED
+                                    if (GUI.connected_to || GUI.connecting_to) {
+                                        $('a.connect').click();
+                                    } else {
+                                        self.disconnect();
+                                    }
+                                    break;
+
+                            }
                         });
 
                         console.log(self.logHead + 'Connection opened with ID: ' + createInfo.socketId + ', url: ' + self.connectionIP + ':' + self.connectionPort);
@@ -294,6 +308,26 @@ var serial = {
 
             var sendFn = (self.connectionType == 'serial') ? chrome.serial.send : chrome.sockets.tcp.send;
             sendFn(self.connectionId, data, function (sendInfo) {
+                // tcp send error
+                if (self.connectionType == 'tcp' && sendInfo.resultCode < 0) {
+                    var error = 'system_error';
+
+                    // TODO: better error handle
+                    // error code: https://cs.chromium.org/chromium/src/net/base/net_error_list.h?sq=package:chromium&l=124
+                    switch (sendInfo.resultCode) {
+                        case -100: // CONNECTION_CLOSED
+                        case -102: // CONNECTION_REFUSED
+                            error = 'disconnected';
+                            break;
+
+                    }
+                    if (callback) callback({
+                         bytesSent: 0,
+                         error: error
+                    });
+                    return;
+                }
+
                 // track sent bytes for statistics
                 self.bytesSent += sendInfo.bytesSent;
 
